#pragma once

namespace GameDBType
{
	/** ?????????
		??????????洢??CharDesc??????У??洢???н?????????????????
		?洢?????????????????С????濪??????????Ч???????????????
		?ж????????????????????б????????????????????????????
		???????????????????????????????????????????
	**/
	typedef struct CharDesc
	{
		const INT64	nCharId;		//???ID????const???????????
		const INT64	nUserId;		//???ID????const???????????
		const CHAR	sCharName[48];	//??????????const???????????
		const CHAR	sAccount[64];	//???????????????????const???????????
		WORD		wState;			//?????1???????CharDescState?е?????????
		WORD		wLevel;			//???
		BYTE		btGender;		//???
		BYTE		btJob;			//??
		BYTE		btReserve0[2];	//----reserve
		INT			nCreateTime;	//???????MiniDateTime??
		INT			nUpdateTime;	//??θ??????MiniDateTime??
		INT			nLoginIP;		//??ε??IP
		WORD		wServerId;		//?????????ID
		BYTE		btReserve1[42];	//???????С?192???
	}CHARDESC, *PCHARDESC;

	/** ????????? **/
	enum CharDescState
	{
		CHARSTATE_DELETED		= 0x4000,	//???????????
		CHARSTATE_DISABLED		= 0x8000,	//??????????????
	};

	/** ???ID???????
		???????????????????ID???κ?Ψ???ID?
	**/
	inline static common::STDGUID makeCharId(WORD wServerId)
	{
		static WORD wXSeries = (WORD)_getTickCount();

		common::STDGUID cid;
		cid.time = CMiniDateTime::now();
		cid.server = wServerId;
		cid.series = wXSeries++;

		return cid;
	}

	//??????ID??????????б???
	//?б??????ID????
	struct CharIdSortedDesc
	{
		CharDesc	*pCharDesc;
	public:
		inline INT_PTR compare (const CharIdSortedDesc & another) const 
		{ 
			if (pCharDesc->nCharId < another.pCharDesc->nCharId) return -1; 
			else if (pCharDesc->nCharId > another.pCharDesc->nCharId) return 1; 
			//????????????б??д洢????????????????????
			else { Assert(pCharDesc == another.pCharDesc); return 0; }
		}
		inline INT_PTR compareKey(const INT64 nId) const 
		{
			if (pCharDesc->nCharId < nId) return -1; 
			else if (pCharDesc->nCharId > nId) return 1; 
			else return 0; 
		}
	};

	//???????????????????б???
	//?б?????????????
	struct CharNameSortedDesc
	{
		CharDesc	*pCharDesc;
	public:
		inline INT_PTR compare (const CharNameSortedDesc & another) const 
		{
			INT_PTR nRet = strcmp(pCharDesc->sCharName, another.pCharDesc->sCharName);
			//????????????б??д洢????????????????????
			if (nRet == 0)
				Assert(pCharDesc == another.pCharDesc);
			return nRet;
		}
		inline INT_PTR compareKey(const LPCSTR sName) const 
		{
			return strcmp(pCharDesc->sCharName, sName);
		}
	};

	//???????ID??????????б???
	//?б????????ID??????????????????????????
	struct UserIdSortedDesc
	{
		CharDesc	*pCharDesc;
	public:
		inline INT_PTR compare (const UserIdSortedDesc & another) const 
		{ 
			if (pCharDesc->nUserId < another.pCharDesc->nUserId) return -1; 
			else if (pCharDesc->nUserId > another.pCharDesc->nUserId) return 1; 
			else return 0; 
		}
		inline INT_PTR compareKey(const INT64 nId) const 
		{
			if (pCharDesc->nUserId < nId) return -1; 
			else if (pCharDesc->nUserId > nId) return 1; 
			else return 0; 
		}
	};

	/** ??????ID????????????б? **/
	typedef CCustomSortList<CharIdSortedDesc, INT64>	CharIdSortList;
	/** ??????????????????????б? **/
	typedef CCustomSortList<CharNameSortedDesc, LPCSTR>	CharNameSortList;
	/** ???????ID????????????б? **/
	typedef CCustomSortList<UserIdSortedDesc, INT64>	UserIdSortList;
}

